// Code generated by goyacc -v  -o grammar.go -p path grammar.y. DO NOT EDIT.

//line grammar.y:2
/*-------------------------------------------------------------------------
 *
 * grammar.y
 *	 Grammar definitions for jsonpath datatype
 *
 * Transforms tokenized jsonpath into tree of JsonPathParseItem structs.
 *
 * Copyright (c) 2019-2024, PostgreSQL Global Development Group
 *
 *-------------------------------------------------------------------------
 */

package parser

import __yyfmt__ "fmt"

//line grammar.y:14

//line grammar.y:18
type pathSymType struct {
	yys int
	str string
}

const TO_P = 57346
const NULL_P = 57347
const TRUE_P = 57348
const FALSE_P = 57349
const IS_P = 57350
const UNKNOWN_P = 57351
const EXISTS_P = 57352
const IDENT_P = 57353
const STRING_P = 57354
const NUMERIC_P = 57355
const INT_P = 57356
const VARIABLE_P = 57357
const OR_P = 57358
const AND_P = 57359
const NOT_P = 57360
const LESS_P = 57361
const LESSEQUAL_P = 57362
const EQUAL_P = 57363
const NOTEQUAL_P = 57364
const GREATEREQUAL_P = 57365
const GREATER_P = 57366
const ANY_P = 57367
const STRICT_P = 57368
const LAX_P = 57369
const LAST_P = 57370
const STARTS_P = 57371
const WITH_P = 57372
const LIKE_REGEX_P = 57373
const FLAG_P = 57374
const ABS_P = 57375
const SIZE_P = 57376
const TYPE_P = 57377
const FLOOR_P = 57378
const DOUBLE_P = 57379
const CEILING_P = 57380
const KEYVALUE_P = 57381
const DATETIME_P = 57382
const BIGINT_P = 57383
const BOOLEAN_P = 57384
const DATE_P = 57385
const DECIMAL_P = 57386
const INTEGER_P = 57387
const NUMBER_P = 57388
const STRINGFUNC_P = 57389
const TIME_P = 57390
const TIME_TZ_P = 57391
const TIMESTAMP_P = 57392
const TIMESTAMP_TZ_P = 57393

var pathToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"TO_P",
	"NULL_P",
	"TRUE_P",
	"FALSE_P",
	"IS_P",
	"UNKNOWN_P",
	"EXISTS_P",
	"IDENT_P",
	"STRING_P",
	"NUMERIC_P",
	"INT_P",
	"VARIABLE_P",
	"OR_P",
	"AND_P",
	"NOT_P",
	"LESS_P",
	"LESSEQUAL_P",
	"EQUAL_P",
	"NOTEQUAL_P",
	"GREATEREQUAL_P",
	"GREATER_P",
	"ANY_P",
	"STRICT_P",
	"LAX_P",
	"LAST_P",
	"STARTS_P",
	"WITH_P",
	"LIKE_REGEX_P",
	"FLAG_P",
	"ABS_P",
	"SIZE_P",
	"TYPE_P",
	"FLOOR_P",
	"DOUBLE_P",
	"CEILING_P",
	"KEYVALUE_P",
	"DATETIME_P",
	"BIGINT_P",
	"BOOLEAN_P",
	"DATE_P",
	"DECIMAL_P",
	"INTEGER_P",
	"NUMBER_P",
	"STRINGFUNC_P",
	"TIME_P",
	"TIME_TZ_P",
	"TIMESTAMP_P",
	"TIMESTAMP_TZ_P",
}

var pathStatenames = [...]string{}

const pathEofCode = 1
const pathErrCode = 2
const pathInitialStackSize = 16

//line grammar.y:36

var pathExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
}

const pathPrivate = 57344

const pathLast = 1

var pathAct = [...]int8{
	1,
}

var pathPact = [...]int16{
	-1000, -1000,
}

var pathPgo = [...]int8{
	0, 0,
}

var pathR1 = [...]int8{
	0, 1,
}

var pathR2 = [...]int8{
	0, 0,
}

var pathChk = [...]int16{
	-1000, -1,
}

var pathDef = [...]int8{
	1, -2,
}

var pathTok1 = [...]int8{
	1,
}

var pathTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
}

var pathTok3 = [...]int8{
	0,
}

var pathErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}


/*	parser for yacc output	*/

var (
	pathDebug        = 0
	pathErrorVerbose = false
)

type pathLexer interface {
	Lex(lval *pathSymType) int
	Error(s string)
}

type pathParser interface {
	Parse(pathLexer) int
	Lookahead() int
}

type pathParserImpl struct {
	lval  pathSymType
	stack [pathInitialStackSize]pathSymType
	char  int
}

func (p *pathParserImpl) Lookahead() int {
	return p.char
}

func pathNewParser() pathParser {
	return &pathParserImpl{}
}

const pathFlag = -1000

func pathTokname(c int) string {
	if c >= 1 && c-1 < len(pathToknames) {
		if pathToknames[c-1] != "" {
			return pathToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func pathStatname(s int) string {
	if s >= 0 && s < len(pathStatenames) {
		if pathStatenames[s] != "" {
			return pathStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func pathErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !pathErrorVerbose {
		return "syntax error"
	}

	for _, e := range pathErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + pathTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(pathPact[state])
	for tok := TOKSTART; tok-1 < len(pathToknames); tok++ {
		if n := base + tok; n >= 0 && n < pathLast && int(pathChk[int(pathAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if pathDef[state] == -2 {
		i := 0
		for pathExca[i] != -1 || int(pathExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; pathExca[i] >= 0; i += 2 {
			tok := int(pathExca[i])
			if tok < TOKSTART || pathExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if pathExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += pathTokname(tok)
	}
	return res
}

func pathlex1(lex pathLexer, lval *pathSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(pathTok1[0])
		goto out
	}
	if char < len(pathTok1) {
		token = int(pathTok1[char])
		goto out
	}
	if char >= pathPrivate {
		if char < pathPrivate+len(pathTok2) {
			token = int(pathTok2[char-pathPrivate])
			goto out
		}
	}
	for i := 0; i < len(pathTok3); i += 2 {
		token = int(pathTok3[i+0])
		if token == char {
			token = int(pathTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(pathTok2[1]) /* unknown char */
	}
	if pathDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", pathTokname(token), uint(char))
	}
	return char, token
}

func pathParse(pathlex pathLexer) int {
	return pathNewParser().Parse(pathlex)
}

func (pathrcvr *pathParserImpl) Parse(pathlex pathLexer) int {
	var pathn int
	var pathVAL pathSymType
	var pathDollar []pathSymType
	_ = pathDollar // silence set and not used
	pathS := pathrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	pathstate := 0
	pathrcvr.char = -1
	pathtoken := -1 // pathrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		pathstate = -1
		pathrcvr.char = -1
		pathtoken = -1
	}()
	pathp := -1
	goto pathstack

ret0:
	return 0

ret1:
	return 1

pathstack:
	/* put a state and value onto the stack */
	if pathDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", pathTokname(pathtoken), pathStatname(pathstate))
	}

	pathp++
	if pathp >= len(pathS) {
		nyys := make([]pathSymType, len(pathS)*2)
		copy(nyys, pathS)
		pathS = nyys
	}
	pathS[pathp] = pathVAL
	pathS[pathp].yys = pathstate

pathnewstate:
	pathn = int(pathPact[pathstate])
	if pathn <= pathFlag {
		goto pathdefault /* simple state */
	}
	if pathrcvr.char < 0 {
		pathrcvr.char, pathtoken = pathlex1(pathlex, &pathrcvr.lval)
	}
	pathn += pathtoken
	if pathn < 0 || pathn >= pathLast {
		goto pathdefault
	}
	pathn = int(pathAct[pathn])
	if int(pathChk[pathn]) == pathtoken { /* valid shift */
		pathrcvr.char = -1
		pathtoken = -1
		pathVAL = pathrcvr.lval
		pathstate = pathn
		if Errflag > 0 {
			Errflag--
		}
		goto pathstack
	}

pathdefault:
	/* default state action */
	pathn = int(pathDef[pathstate])
	if pathn == -2 {
		if pathrcvr.char < 0 {
			pathrcvr.char, pathtoken = pathlex1(pathlex, &pathrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if pathExca[xi+0] == -1 && int(pathExca[xi+1]) == pathstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			pathn = int(pathExca[xi+0])
			if pathn < 0 || pathn == pathtoken {
				break
			}
		}
		pathn = int(pathExca[xi+1])
		if pathn < 0 {
			goto ret0
		}
	}
	if pathn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			pathlex.Error(pathErrorMessage(pathstate, pathtoken))
			Nerrs++
			if pathDebug >= 1 {
				__yyfmt__.Printf("%s", pathStatname(pathstate))
				__yyfmt__.Printf(" saw %s\n", pathTokname(pathtoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for pathp >= 0 {
				pathn = int(pathPact[pathS[pathp].yys]) + pathErrCode
				if pathn >= 0 && pathn < pathLast {
					pathstate = int(pathAct[pathn]) /* simulate a shift of "error" */
					if int(pathChk[pathstate]) == pathErrCode {
						goto pathstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if pathDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", pathS[pathp].yys)
				}
				pathp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if pathDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", pathTokname(pathtoken))
			}
			if pathtoken == pathEofCode {
				goto ret1
			}
			pathrcvr.char = -1
			pathtoken = -1
			goto pathnewstate /* try again in the same state */
		}
	}

	/* reduction by production pathn */
	if pathDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", pathn, pathStatname(pathstate))
	}

	pathnt := pathn
	pathpt := pathp
	_ = pathpt // guard against "declared and not used"

	pathp -= int(pathR2[pathn])
	// pathp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if pathp+1 >= len(pathS) {
		nyys := make([]pathSymType, len(pathS)*2)
		copy(nyys, pathS)
		pathS = nyys
	}
	pathVAL = pathS[pathp+1]

	/* consult goto table to find next state */
	pathn = int(pathR1[pathn])
	pathg := int(pathPgo[pathn])
	pathj := pathg + pathS[pathp].yys + 1

	if pathj >= pathLast {
		pathstate = int(pathAct[pathg])
	} else {
		pathstate = int(pathAct[pathj])
		if int(pathChk[pathstate]) != -pathn {
			pathstate = int(pathAct[pathg])
		}
	}
	// dummy call; replaced with literal code
	switch pathnt {

	case 1:
		pathDollar = pathS[pathpt-0 : pathpt+1]
//line grammar.y:35
		{
		}
	}
	goto pathstack /* stack new state and value */
}
